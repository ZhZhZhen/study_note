# 作用域链
js采用静态作用域，一个函数被创建的时候，其能访问的标识符就已经确定，这是因为函数内部的[[scope]]属性在创建时已经确定。
以es6为例
函数在被创建的时候，内部的[[scope]]属性会指向所在的父执行上下文的词法环境（LexicalEnvironment）。而该函数执行前会创建执行上下文，并创建词法环境，该词法环境的outer指向的是函数[[scope]]所记录的词法环境。以此形成了作用域链。

#补充描述：
1、es5及之后都采用词法环境来记录声明的变量和函数，在es3时执行上下文只包括this/变量对象VO/scope。以数组形式来描述，一个函数在创建的时候其[[scope]]属性复制了父执行上下文的scope。并且在函数执行前创建的执行上下文中，会创建变量对象VO来记录声明的变量和函数，而当前执行上下文的scope则等同于VO+[[scope]]。全局执行上下文的scope中仅仅包含了作为变量对象的global。以此形成作用域链
2、函数的[[Scope]]属性：函数被创建时的一个内部属性。即使函数未被执行，该属性也一直存在。通过构造方法创建的函数，其[[Scope]]仅包含全局对象(es3)/全局上下文的词法环境(es5及之后)。
3、es3作用域链的查找过程中，在最终查找全局对象VO的时候，若没查找到，则会通过原型链查找属性（仅发生在全局对象VO上；函数执行上下文的变量对象，即活动对象AO没有原型）
4、es6之后增加了块级作用域，块级作用域也会创建词法环境，通过outer来指向上一个词法环境。
5、命名函数表达式，为了记录本身的函数命名，其[[scope]]会指向一个额外创建的词法环境，该词法环境的环境记录仅包含函数命名，outer指向的是父词法环境；es3中也有类似的处理，在创建命名函数表达式的时候，会生成一个特殊对象仅包含函数命名，并加入执行上下文scope的头部，命名函数表达式的[[scope]]在创建时复制了包含特殊对象的scope，而在创建完命名函数表达式后，该特殊对象会从执行上下文scope中移除。
6、ES6后块级作用域内的函数声明：在其他环境中块级作用域声明的函数和let一样，只在块内可见；但是ES6浏览器为了解决老代码的兼容问题，块级作用域的函数声明既会提升至块级作用域头部也会提升至外层的函数/全局作用域头部，但是外层作用域的函数标识符不会立刻指向函数体，而是初始化为undefined，并在代码执行到对应函数声明位置的时候将此时块内标识符的值复制给外部作用域的标识符（如果此时标识符已经不是指向函数体，也会复制给外部作用域的标识符）。
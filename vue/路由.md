# 路由

### 概述
- 服务端路由：指的是服务端根据用户访问的URL路径返回不同的响应结果。即浏览器从服务端获取URL对应的HTML，然后重新加载页面。
- 客户端路由：客户端通过JS拦截页面跳转请求，动态获取新的数据，在无需重新加载的情况下更新当前页面。
##### 路由器
>客户端路由器的职责就是利用HistoryAPI或是hashchange事件这样的浏览器API，将浏览器的 URL 和用户看到的内容绑定起来，来管理应用当前应该渲染的视图。
- 一般使用Vue Router进行路由管理
- 如果自己编写路由，则需要搭配HistoryAPI或监听hashchange事件，利用动态组件<component/>来切换不同的视图。

# Vue Router

### 创建并注册路由器实例
- 通过routes选项定义一组路由，把URL路径映射到组件。由component参数指定的组件会渲染在RouterView中
- history选项控制路由和URL路径如何双向映射
- 注册过程中全局注册了RouterLink/RouterView组件；添加全局\$router和\$route属性；启用useRoute/useRouter组合式函数；触发路由器解析初始路由

```
const routes = [
  { path: '/', component: HomeView },
  { path: '/about', component: AboutView },
]

const router = createRouter({
  history: createMemoryHistory(),
  routes,
})

//在应用实例中注册使用
createApp(App)
  .use(router)
  .mount('#app')
```
##### 访问路由器和当前路由
> 路由器指router；当前路由指route
- 在模板中可以使用\$router和\$route进行访问
- 组合式API中，可以使用useRouter/useRoute
- 选项式API中，可以使用this.\$router和this.\$route
- 其他代码位置，使用ES模块语法直接导入

##### 跳转
```
//使用RouterLink创建链接，使用RouterView定义组件渲染位置
<RouterLink to="/">Go to Home</RouterLink>
<RouterView />
```


### 定义路由
- 以下内容省略了component属性
- 调试路由：[链接](https://paths.esm.dev/?p=AAMeJSyAwR4UbFDAFxAcAGAIJXMAAA..)

##### 路由选项
```
//在配置路由时可以有额外选项
{ path: '/users/:id', sensitive: true }
```
- strict：路径末尾不包含/
- sensitive：严格匹配大小写
- children：定义嵌套路由，见下文
- name：命名路由，见下文
- redirect：重定向
  ```
  { path: '/home', redirect: '/' }
  ```
  - redirect可以指定路径，相对路径，对象（支持命名路由），方法（内部返回对象）
  - 导航守卫会在重定向的目标上触发，而过渡中的路由不会触发
  - 写redirect时，大部分情况可以省略compoment，但是包含children时必须写component
- alias：路径别名
  ```
  { path: '/', component: Homepage, alias: '/home' }
  ```
  - 别名和重定向的区别在于，访问别名时URL不会被替换
  - alias可以指定相对路径，路径数组。若主路径包含参数时，别名中的绝对路径也需要包含参数
  - 使用别名时，一定要[定义规范链接](https://developers.google.com/search/docs/crawling-indexing/consolidate-duplicate-urls?visit_id=638707037545835232-3753361904&rd=1&hl=zh-cn)
- props：用于传递参数
  >在组件中访问\$route会使得组件被耦合，只能用于路由，替代的方式是通过声明props并进行传递
  - 布尔模式：当props为true时，route.params会当作组件的props
    ```
    { path: '/user/:id', component: User, props: true }
    ```
  - 对象模式：当props为对象时，对象的属性会被当作组件的props
  - 函数模式：函数返回的对象，其属性会被当作组件的props
  - 当配合命名视图使用时，props选项需要和component选项一样传递一个对象，为每个命名视图分别配置

##### 静态路由
  ```
  { path: '/about' }
  ```
- 以/开头的是绝对路径，不以/开头的是相对路径（常用在嵌套路由中）
##### 动态路由（带参数）
>使用冒号定义（可以定义多个）。并通过\$route.params进行访问。
```
{ path: '/users/:id' }
//模板中访问
$route.params.id
```
- 带参数的路由在参数变化时，相同的组件实例将被复用，因此组件的生命周期钩子不会被调用。若要对参数变动做出响应，可以使用侦听器侦听params内容的变化，或使用路由守卫。
- 常规参数只匹配url片段之间的字符，即//之间，若想匹配任意路径可以使用正则表达式。

##### 在参数中使用正则
- 自定义正则表达式
    ```
    //注意使用\\进行转义
    { path: '/:orderId(\\d+)' }
    ```
- 匹配重复参数
    - 使用?匹配0或1个，+匹配1或多个，*匹配0或多个
    ```
    //chapters匹配 /one, /one/two等
     { path: '/:chapters+' },
    //访问时会记录为一个数组，chapters是一个数组
    $route.params.chapters
    //搭配自定义正则表达式使用，匹配/, /1, /1/2
    { path: '/:chapters(\\d+)*' }
    ```

##### 嵌套路由
> 通常顶层会包含一个RouterView渲染内容，同时被渲染的组件本身也可以使用RouterView定义嵌套路由的渲染位置
- 通过在路由中配置children属性来定义嵌套路由，这是一个由路由组成的数组
    ```
    {
        path: '/user/:id',
        component: User,
        children: [
            // 当 /user/:id/profile 匹配成功时，UserProfile 将被渲染到 User 的 <RouterView> 内部
            { path: 'profile', component: UserProfile},
            //当 /user/:id 匹配成功时，UserHome 将被渲染到 User 的 <router-view> 内部
            { path: '', component: UserHome },
        ],
    }
    ```
- 嵌套路由中，path指定空字符串，则子路由将作为导航到父路由时的默认显示
- 使用嵌套路由时，若不指定父路由的component属性，则将在顶层RouterView中直接渲染子路由组件。
- 搭配命名路由使用时，可以直接导航到对应的子路由（使用子路由的命名），若使用父路由的命名进行导航，则不会显示子路由。

##### 命名路由
> 通过给路由定义name，来代替path的方式进行链接
```
//定义命名路由，命名需唯一，若重复路由器只保留最后一个命名
{ path: '/user/:username', name: 'profile', component: User}
//使用命名进行跳转
<router-link :to="{ name: 'profile', params: { username: 'erina' } }">
  User profile
</router-link>
```
- 命名路由可以取消硬编码，防止打字错误
- 可以绕过路径排序，直接访问一个匹配相同路径但是排序较低的路由
- 进行params的自动编/解码


### 编程式导航
>通过路由器实例方法来进行导航
- 导航
  ```
  //点击RouterLink内部其实就是调用了该方法
  router.push(...)
  // 字符串路径
  router.push('/users/eduardo')
  // 带有路径的对象
  router.push({ path: '/users/eduardo' })
  // 命名的路由，并加上参数，让路由建立 url
  router.push({ name: 'user', params: { username: 'eduardo' } })
  // 带查询参数，结果是 /register?plan=private
  router.push({ path: '/register', query: { plan: 'private' } })
  // 带 hash，结果是 /about#team
  router.push({ path: '/about', hash: '#team' })
  ```
  - 当使用path进行导航时，params会被忽略。params需要搭配命名路由使用；或者在编写path时直接指定参数。
- 替换
  ```
  router.replace(...)
  ```
  - 当调用push时，使用replace有相同效果
    ```
    router.push({ path: '/home', replace: true })
    ```
- 横跨历史
  ```
  // 向前移动一条记录，与 router.forward() 相同
  router.go(1)
  // 返回一条记录，与 router.back() 相同
  router.go(-1)
  // 前进 3 条记录
  router.go(3)
  // 如果没有那么多记录，静默失败
  router.go(-100)
  ```


### 导航守卫




### 其他
##### 命名视图
> 用于同时展示多个视图（RouterView）
```
//无name时则为default
<router-view name="LeftSidebar" />
<router-view />
<router-view name="RightSidebar" />

//通过为路由的component属性配置对象完成
{
    path: '/',
    components: {
      default: Home,
      LeftSidebar: LeftSidebar,
      //若组件标识符与name相同，则可以缩写
      RightSidebar,
    },
  }
```
- 命名视图可以和嵌套路由组合使用。
- 若对应命名视图不需要展示内容，则在配置component属性时直接忽略就好。

##### 路由器history选项
- HTML5模式：createWebHistory, 编写网页时使用。
  - 编写单页面应用的时候，服务端要处理访问不存在页面时的回退，将页面导航至单页面应用。此时我们需要在单页面应用中处理404的情况。
- Memory模式：createMemoryHistory, 基于内存的历史，用于服务端渲染。不会触发初始导航，无法后退前进
- Hash模式：createWebHashHistory, 用于没有主机的web应用（如file://）

##### 链接激活样式
> 当前路由若匹配页面中的RouterLink时，可以通过激活样式来改变其外观

路由的path和params，alias会作为匹配的考虑项。
- router-link-active：当匹配子路由时，父子路由的该类都会生效。
- router-link-exact-active：当匹配子路由时，只有子路由的该类会生效。
- 可以通过RouterLink的activeClass/exactActiveClass改变类名；或路由器实例创建时linkActiveClass/linkExactActiveClass全局改变类名

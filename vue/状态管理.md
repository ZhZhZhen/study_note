# 状态管理

### 概述
Vue的状态和组件是解耦的。
当组件状态难以维护时，可以抽取共享状态置于组件之外并进行管理。
- 自己编写：可以把响应式API如：reactive/ref/computed声明在一个全局单例中
    - *维护一个单例状态对于服务端渲染来说，它是跨多个请求共享的，所以可能导致问题。
- 使用Pinia
支持服务端渲染/模块热更新/Vue DevTools集成，是作为替代Vuex的状态管理库

# Pinia
### 定义Store
- 通过defineStore定义，第一个参数为id（唯一），第二个参数接收选项式对象或setup函数
- 通常以use开头，store结尾，id为名进行命名
```
export const useAlertsStore = defineStore('alerts', {
  // 其他配置...
})
```
#### Setup Store
- 使用类似于Vue组合式API，在其中可以使用ref, reactive, computed, 函数定义等。
- 其中定义的属性和方法需要作为对象的内容在最后返回，才会被pinia识别。不要使用私有属性。
- setup store可以通过inject访问全局注入的内容
```
export const useCounterStore = defineStore('counter', () => {
    //相当于data
    const count = ref(0)
    //相当于computed
    const doubleCount = computed(() => count.value * 2)
    //相当于methods
    function increment() {
        count.value++
    }
    
    return { count, doubleCount, increment }
})
```

#### Option Store
- 类似Vue的选项式API，通过定义state, getters, actions来定义内容，相当于Vue的data, computed(具有缓存功能), methods。
- 定义state的时候需定义一个返回初始状态的函数。
```
export const useCounterStore = defineStore('counter', {
    state: () => ({ count: 0, name: 'Eduardo' }),
    getters: {
        doubleCount: (state) => state.count * 2,
    },
    actions: {
        increment() {
            this.count++
        },
    },
})
```

#### 使用
- 在\<script setup>或setup选项中调用，返回的是一个reactive包装的对象。
- 返回的对象，其中的actions可以直接解构，state和getters需要通过storeToRefs解构获得。
```
const store = useCounterStore()
const { name, doubleCount } = storeToRefs(store)
const { increment } = store
```


### State
#### 访问state
- 通过store实例直接读写state
```
const store = useStore()
store.count++
```

#### 重置state
- option store可以直接调用store.$reset()方法，内部会调用state()创建一个新的状态对象并替换当前状态。
- setup store需要在setup中定义$reset()方法

#### 变更state
- 通过store.$patch()一次性修改多个变更，支持传递对象或函数，多个变更可以在devtools中被归为一个条目。
- 不能替换store的state，因为会破坏响应性，所以想替换时使用$patch
```
store.$patch({
  count: store.count + 1,
  age: 120,
})

store.$patch((state) => {
  state.items.push({ name: 'shoes', quantity: 1 })
  state.hasChanged = true
})
```

#### 订阅state
- 通过store.$subscribe()对状态变更进行订阅，相比于watch，优点在于patch后只会触发一次回调。
- 默认情况订阅器会绑定至组件上，并随着组件卸载被删除；如果不绑定组件生命周期，则可以将{detached: true}作为第二个参数传入，以从当前组件分离。
```
cartStore.$subscribe((mutation, state) => {
    mutation.type // 'direct' | 'patch object' | 'patch function'
    mutation.storeId // 创建store的id，和cartStore.$id一样
    mutation.payload //  mutation.type为patch object可用，代表传递给cartStore.$patch()的补丁对象。
    localStorage.setItem('cart', JSON.stringify(state))//状态变更时持久化到本地
})

someStore.$subscribe(callback, { detached: true })//将订阅器从组件分离
```


### Getter